# Projeto-Sistema-SUS-II
Projeto 2 para a disciplina de Algoritmos e estruturas de dados com o professor Rudinei Goularte, no ICMC - USP
Integrantes do grupo:
Rafael Pavon Diesner - 16898096
Enzo Ferreira de Castro Lima - 16863736
Eric Costa Lopes - 17070779

# Visão Geral
O projeto consiste em uma atualização do sistema de atendimento do SUS, realizado como projeto 1 para esta disciplina. Agora, as principais operações de inserção, remoção e busca de pacientes nos registros do hospital são feitas com complexidade logarítmica, buscando a maior eficiência de operações possível. O gerenciamento de memória também foi feito da maneira mais eficiente possível, buscando atender as demandas do hospital. Para o sistema, dessa vez, transformamos a lista de pacientes salvos no sistema do hospital em uma AVL, ao invés de uma lista, para que as operações de busca, remoção e inserção tenham eficiência logarítmica. No caso da fila de triagem, por conta da necessidade de lidar com os diferentes níveis de prioridade, transformamos ela em uma fila de prioridade (uma min heap, com a ordem de chegada como critério de desempate). A lógica do histórico médico que cada paciente possui foi mantida a mesma do último trabalho, que será explicada adiante. As funções de salvar e carregar os dados do sistema, dessa vez, foram implementadas como funções nos TAD fila e TAD avl, ao invés de terem um TAD próprio.

# TAD AVL
A AVL é a estrutura de dados que guarda as informações de todos os pacientes que já passaram pelo hospital, o que inclui ID único, nome e histórico médico. A avl consiste basicamente em uma árvore binária de busca (valores maiores à direita e menores à esquerda) que se balanceia a cada inserção ou remoção. Isso faz com que a eficiência logarítmica das árvores seja mantida, impedindo que os desbalanceamentos degenerem a árvore e diminuam a eficiência das operações. Para realizar o balanceamento, temos as funções de rotação que balanceiam a árvore sempre que uma subárvore possui uma diferença de altura entre suas subárvores maior que 1. Na avl, as operações de inserção, remoção e busca tem complexidade O(log n). A avl foi implementada de modo encadeado, pois como a lista de pacientes não tem tamanho máximo, a implementação encadeada nos dá um melhor gerenciamento de memória para o sistema.

# TAD fila
A fila de triagem, agora, não depende apenas da ordem de chegada dos pacientes, ela depende também do estado de emergência do paciente, que é registrado quando entra na fila. O nível de emergência é representado por um valor que vai de 1 a 5, sendo 1 o nível que requer atendimento imediato e 5 casos de nenhum risco à vida do paciente. A estrutura de dados escolhida para representar essa fila de prioridade baseada no nível de emergência foi uma min heap. Em casos de mesmos níveis de emergência, o critério de desempate é a ordem de chegada na fila, de modo que quem chegou primeiro é atendido antes, mas o nível de emergência tem peso maior que a ordem de chegada. A fila de prioridade foi implementada como uma heap sequencial (array) de tamanho máximo 250 buscando a maior eficiência das operações. As operações de inserção e remoção tem complexidade O(log n), já no caso da busca, a complexidade é de O(n), mas como a fila usada tem um pequeno tamanho máximo, a operação de busca não prejudica de forma notável a eficiência do programa. As informações de ordem de chegada e nível de urgência do tratamento de cada paciente são guardadas na struct nó da fila de prioridade, pelo fato de que o mesmo paciente pode entrar na fila em diferentes momentos, com diferentes níveis de prioridade e portanto essas características não são fixas para cada paciente. Para evitar uso desnecessário de memória e usar apenas o estritamente necessário, a única informação do paciente que armazenamos na fila (além dos inteiros usados na ordenação) é o id do paciente, de modo que com o id, se desejemos saber qualquer informação sobre o paciente em questão, é apenas necessário que se busque pelo id na lista, o que é uma tarefa rápida já que a busca em avl tem eficiência de O(log n).

# TAD histórico e TAD procedimento
O histórico de tratamento de cada paciente é gerenciado por uma pilha simplesmente encadeada. A escolha desta estrutura se deve ao fato de que o último procedimento médico adicionado é o primeiro a ser desfeito. Cada paciente pode ter no máximo 10 procedimentos em seu histórico. As funcionalidades do histórico médico incluem:
Inserir procedimento: adiciona um novo procedimento no topo da pilha do histórico do paciente. Complexidade constante.
Retirar procedimento: remove o procedimento mais recatendimento aos pacientes.ente do histórico. Complexidade constante
Consultar histórico: exibe todos os procedimentos no histórico de um paciente. Complexidade linear em função do tamanho do histórico.
Verificar se o histórico está cheio ou vazio: controla o número de procedimentos registrados. Complexidade constante. Para esse TAD, criamos um TAD procedimento, para mais fácil organização das operações diretas sobre os procedimentos. A utilização de uma pilha encadeada evita que seja alocado mais memória que será usada.

# As funções de save e load
Para realizar a permanência dos dados, implementamos dentro dos TADs avl e fila as funções para salvar e carregar os dados do sistema correspondentes aos registros dos pacientes e da fila de espera, respectivamente. Para a avl, nós criamos um vetor auxiliar com o tamanho que equivale a quantidade de nós que uma árvore binária completamente cheia com altura igual à da nossa avl teria e salvamos recursivamente o nó na posição "i", o filho esquerdo em "2i+1" e o filho direito em "2i+2". Quando tivermos um nó nulo, iremos representá-lo com um nó chamado de vazio. Para a load, nós pegamos esse vetor e recursivamente reconstruímos a avl, verificando se o nó é vazio ou não, e se for vazio, salvamos o espaço como null. Para a fila de prioridade, apenas copiamos o vetor que a representa no arquivo e depois lemos esse vetor na load para carregar os dados. No salvamento da avl, salvamos todas as informações do paciente (nome, id e histórico), enquanto no salvamento da fila salvamos apenas os ids, buscando economizar memória e não salvar repetidas vezes as informações de cada paciente.
